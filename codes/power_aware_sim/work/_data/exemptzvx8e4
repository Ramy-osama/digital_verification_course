library ieee;
use ieee.std_logic_1164.all;
use ieee.UPF.all;
package mspa_pack_vh is
signal pa_std_logic_const_0 : STD_LOGIC := '0';
signal pa_std_logic_const_1 : STD_LOGIC := '1';
signal pa_std_logic_const_Z : STD_LOGIC := 'Z';
signal pa_bit_const_0 : BIT := '0';
signal pa_bit_const_1 : BIT := '1';
	-- Declarations corresponding to Power Control Signals --
	-- triggered by UPF hierarchy.                         --
	------------------------------------------------------
	signal paopt_t0cond : std_logic;
	signal mspa3_iso_gated_to_aon_ISO_ENABLE : std_logic;
	signal mspa2_iso_gated_to_aon_ISO_PWR : std_logic;
	signal mspa1_PD_GATED_DOMAIN_PWR : std_logic;
	signal mspa0_PD_AON_DOMAIN_PWR : std_logic;
	------------------- End PCS Declarations ----------------
	signal mspa0_PD_AON_DOMAIN_PWR_2 : std_logic := '1';
	signal mspa2_iso_gated_to_aon_ISO_PWR_4 : std_logic := '1';
	signal mspa1_PD_GATED_DOMAIN_PWR_3 : std_logic := '1';
		signal mspa1_PD_GATED_DOMAIN_PWR_3_wire : std_logic := '1';
		signal mspa2_iso_gated_to_aon_ISO_PWR_4_wire : std_logic := '1';
		signal mspa0_PD_AON_DOMAIN_PWR_2_wire : std_logic := '1';
function qspa_xor (l : STD_ULOGIC_VECTOR) return STD_ULOGIC;
function qspa_to_bit_from_bool(l : BOOLEAN) return BIT;
function qspa_to_bit(l : STD_ULOGIC) return BIT;
function qspa_to_stdlogic(l : BIT) return STD_ULOGIC;
function qspa_to_stdlogicvector(l : BIT_VECTOR) return STD_ULOGIC_VECTOR;
function qspa_char_to_stdlogic(l : CHARACTER) return STD_ULOGIC;
function qspa_string_to_stdlogicvector(l : STRING) return STD_ULOGIC_VECTOR;
constant sPaOptionString : string := "PA_OPT_DESIGN_NAME = T:/work/opt_tb__pa_opt PAHIERPATHCNT 4 ";

end package;
package body mspa_pack_vh is
function qspa_xor (l : STD_ULOGIC_VECTOR) return STD_ULOGIC is
  variable result : STD_ULOGIC := '0';
begin
  for i in l'reverse_range loop
    result := l(i) xor result;
  end loop;
  return result;
end function qspa_xor;
function qspa_to_bit_from_bool(l : BOOLEAN) return BIT is
begin
case l is
	when false => return '0';
	when true => return '1';
end case;
end function qspa_to_bit_from_bool;
function qspa_to_bit (l : STD_ULOGIC ) return BIT is
begin
  case l is
    when '0' | 'L' => return ('0');
    when '1' | 'H' => return ('1');
    when others    => return ('0');
  end case;
end function qspa_to_bit;
function qspa_to_stdlogic(l : BIT) return STD_ULOGIC is
begin
case l is
	when '0' => return '0';
	when '1' => return '1';
end case;
end function qspa_to_stdlogic;
function qspa_to_stdlogicvector(l : BIT_VECTOR) return STD_ULOGIC_VECTOR is
  alias bv        : BIT_VECTOR (l'length-1 downto 0) is l;
  variable result : STD_ULOGIC_VECTOR (l'length-1 downto 0);
begin
  for i in result'range loop
    case bv(i) is
      when '0' => result(i) := '0';
      when '1' => result(i) := '1';
    end case;
  end loop;
  return result;
end function qspa_to_stdlogicvector;
function qspa_char_to_stdlogic(l : CHARACTER) return STD_ULOGIC is
begin
case l is
	when '0' => return '0';
	when '1' => return '1';
	when 'z' | 'Z' => return 'Z';
 when others    => return ('0');
end case;
end function qspa_char_to_stdlogic;
function qspa_string_to_stdlogicvector(l : STRING) return STD_ULOGIC_VECTOR is
  alias bv        : STRING(l'length downto 1) is l;
  variable result : STD_ULOGIC_VECTOR (l'length downto 1);
begin
  for i in l'length downto 1 loop
    case bv(i) is
      when '0' => result(i) := '0';
      when '1' => result(i) := '1';
      when 'z' | 'Z' => result(i) := 'Z';
      when others    => result(i) := '0';
    end case;
  end loop;
  return result;
end function qspa_string_to_stdlogicvector;
end package body mspa_pack_vh;
----std_ulogic types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_u_vec_vh is
  generic(
		msb : integer := 0;
		chkid : integer := 0);
  port(isolation_input: in std_ulogic_vector(msb downto 0);
	   isolation_output: out std_ulogic_vector(msb downto 0);	  
	   clamp_value: in std_ulogic_vector(msb downto 0);
	   power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_u_vec_vh;

architecture rtl of mspa_iso_chk_cell_u_vec_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= (others => 'X');
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= (others => 'X');
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_u_latch_vec_vh is
  generic(
		msb : integer := 0;
		chkid : integer := 0);
  port(isolation_input: in std_ulogic_vector(msb downto 0);
	   isolation_output: out std_ulogic_vector(msb downto 0);	  
	   power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_u_latch_vec_vh;

architecture rtl of mspa_iso_chk_cell_u_latch_vec_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= (others => 'X');
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= (others => 'X');
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_u_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in std_ulogic;
	     isolation_output: out std_ulogic;
	     clamp_value :in std_ulogic;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_u_vh;

architecture rtl of mspa_iso_chk_cell_u_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= 'X';
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= 'X';
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_u_latch_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in std_ulogic;
	     isolation_output: out std_ulogic;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_u_latch_vh;

architecture rtl of mspa_iso_chk_cell_u_latch_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= 'X';
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= 'X';
		end if;	
	end process;

end architecture;

----x01 types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_x01z_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in x01z;
	     isolation_output: out x01z;
	     clamp_value :in std_ulogic;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_x01z_vh;

architecture rtl of mspa_iso_chk_cell_x01z_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= 'X';
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= 'X';
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_x01z_latch_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in x01z;
	     isolation_output: out x01z;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_x01z_latch_vh;

architecture rtl of mspa_iso_chk_cell_x01z_latch_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= 'X';
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= 'X';
		end if;	
	end process;

end architecture;

----std_logic types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_vec_vh is
  generic(
		msb : integer := 0;
		chkid : integer := 0);
  port(isolation_input: in std_logic_vector(msb downto 0);
	   isolation_output: out std_logic_vector(msb downto 0);	  
	   clamp_value: in std_ulogic_vector(msb downto 0);
	   power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_vec_vh;

architecture rtl of mspa_iso_chk_cell_vec_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= (others => 'X');
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= (others => 'X');
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_latch_vec_vh is
  generic(
		msb : integer := 0;
		chkid : integer := 0);
  port(isolation_input: in std_logic_vector(msb downto 0);
	   isolation_output: out std_logic_vector(msb downto 0);	  
	   power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_latch_vec_vh;

architecture rtl of mspa_iso_chk_cell_latch_vec_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= (others => 'X');
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= (others => 'X');
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in std_logic;
	     isolation_output: out std_logic;
	     clamp_value :in std_ulogic;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_vh;

architecture rtl of mspa_iso_chk_cell_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= 'X';
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= 'X';
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_latch_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in std_logic;
	     isolation_output: out std_logic;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_latch_vh;

architecture rtl of mspa_iso_chk_cell_latch_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= 'X';
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= 'X';
		end if;	
	end process;

end architecture;

--ENUM TYPES MODEL---------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_enum_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in Integer;
	     isolation_output: out Integer;
 	 	 clamp_value :in Integer;
         corrupt_value :in Integer;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_enum_vh;

architecture rtl of mspa_iso_chk_cell_enum_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= corrupt_value;
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= corrupt_value;
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_enum_latch_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in Integer;
	     isolation_output: out Integer;
         corrupt_value :in Integer;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_enum_latch_vh;

architecture rtl of mspa_iso_chk_cell_enum_latch_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= corrupt_value;
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= corrupt_value;
		end if;	
	end process;

end architecture;

----BIT TYPE MODEL---------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_bit_vec_vh is
  generic(
		msb : integer := 0;
		chkid : integer := 0);
  port(isolation_input: in bit_vector(msb downto 0);
	   isolation_output: out bit_vector(msb downto 0);
	   clamp_value: in bit_vector(msb downto 0);
	   power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_bit_vec_vh;

architecture rtl of mspa_iso_chk_cell_bit_vec_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= (others => '0');
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= (others => '0');
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_bit_latch_vec_vh is
  generic(
		msb : integer := 0;
		chkid : integer := 0);
  port(isolation_input: in bit_vector(msb downto 0);
	   isolation_output: out bit_vector(msb downto 0);	  
	   power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_bit_latch_vec_vh;

architecture rtl of mspa_iso_chk_cell_bit_latch_vec_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= (others => '0');
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= (others => '0');
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_bit_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in bit;
	     isolation_output: out bit;
 	     clamp_value     : in bit;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_bit_vh;

architecture rtl of mspa_iso_chk_cell_bit_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= '0';
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= '0';
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_bit_latch_vh is
  generic(
		chkid : integer := 0);
  port(isolation_input: in bit;
	     isolation_output: out bit;
	     power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_bit_latch_vh;

architecture rtl of mspa_iso_chk_cell_bit_latch_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= '0';
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= '0';
		end if;	
	end process;

end architecture;


----Integer types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_int_vh is
  generic(
		msb : integer := 0;
 	 	  lsb : integer := 0;
		  chkid : integer := 0);
  port(isolation_input: in integer range msb downto lsb;
			 isolation_output: out integer range msb downto lsb;	  
			 clamp_value :in integer;
			 corrupt_value :in integer;
			 power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_int_vh;

architecture rtl of mspa_iso_chk_cell_int_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= corrupt_value;
			elsif(isolation_signal = '1') then
			    isolation_output <= clamp_value;
			else 	
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= corrupt_value;
		end if;	
	end process;

end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_iso_chk_cell_int_latch_vh is
  generic(
		msb : integer := 0;
 	 	  lsb : integer := 0;
		  chkid : integer := 0);
  port(isolation_input: in integer range msb downto lsb;
			 isolation_output: out integer range msb downto lsb;	  
			 corrupt_value :in integer;
			 power,isolation_signal,sink_pwr :in std_logic;
			 portid,pdid : in integer);
end mspa_iso_chk_cell_int_latch_vh;

architecture rtl of mspa_iso_chk_cell_int_latch_vh is
begin
 	pcs:process(power,isolation_signal,isolation_input)	begin
	  	if(power = '1') then
		    if(isolation_signal = 'X') then
			    isolation_output <= corrupt_value;
			elsif(isolation_signal /= '1') then
			    isolation_output <= isolation_input;
			end if;	
		else 	
		    isolation_output <= corrupt_value;
		end if;	
	end process;

end architecture;

--- LS -----
----std_ulogic types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_u_vec_vh is
  generic(msb : integer := 0);
  port(ls_input: in std_ulogic_vector(msb downto 0);
	   ls_output: out std_ulogic_vector(msb downto 0);	  
	   internal_supply :in std_logic);
end mspa_ls_cell_u_vec_vh;

architecture rtl of mspa_ls_cell_u_vec_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else (others => 'X');
end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_u_vh is
  port(ls_input: in std_ulogic;
	     ls_output: out std_ulogic;
	     internal_supply :in std_logic);
end mspa_ls_cell_u_vh;

architecture rtl of mspa_ls_cell_u_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else 'X';
end architecture;

----x01 types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_x01z_vh is
  port(ls_input: in x01z;
	     ls_output: out x01z;
	     internal_supply :in std_logic);
end mspa_ls_cell_x01z_vh;

architecture rtl of mspa_ls_cell_x01z_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else 'X';
end architecture;

----std_logic types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_vec_vh is
  generic(msb : integer := 0);
  port(ls_input: in std_logic_vector(msb downto 0);
	   ls_output: out std_logic_vector(msb downto 0);	  
	   internal_supply :in std_logic);
end mspa_ls_cell_vec_vh;

architecture rtl of mspa_ls_cell_vec_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else (others => 'X');
end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_vh is
  port(ls_input: in std_logic;
	     ls_output: out std_logic;
	     internal_supply :in std_logic);
end mspa_ls_cell_vh;

architecture rtl of mspa_ls_cell_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else 'X';
end architecture;

--ENUM TYPES MODEL---------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_enum_vh is
  port(ls_input: in Integer;
	     ls_output: out Integer;
         corrupt_value :in Integer;
	     internal_supply :in std_logic);
end mspa_ls_cell_enum_vh;

architecture rtl of mspa_ls_cell_enum_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else corrupt_value;
end architecture;

----BIT TYPE MODEL---------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_bit_vec_vh is
  generic(msb : integer := 0);
  port(ls_input: in bit_vector(msb downto 0);
	   ls_output: out bit_vector(msb downto 0);
	   internal_supply :in std_logic);
end mspa_ls_cell_bit_vec_vh;

architecture rtl of mspa_ls_cell_bit_vec_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else (others => '0');
end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_bit_vh is
  port(ls_input: in bit;
	     ls_output: out bit;
	     internal_supply :in std_logic);
end mspa_ls_cell_bit_vh;

architecture rtl of mspa_ls_cell_bit_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else '0';
end architecture;

----Integer types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_ls_cell_int_vh is
  generic(msb : integer := 0;
 	 	  lsb : integer := 0);
  port(ls_input: in integer range msb downto lsb;
			 ls_output: out integer range msb downto lsb;	  
			 corrupt_value :in integer;
			 internal_supply :in std_logic);
end mspa_ls_cell_int_vh;

architecture rtl of mspa_ls_cell_int_vh is
begin
	pcs: ls_output <= ls_input when internal_supply = '1' else corrupt_value;
end architecture;

---- RS Buffers --------------------
----std_ulogic types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_u_vec_vh is
  generic(msb : integer := 0);
  port(buf_input: in std_ulogic_vector(msb downto 0);
	   buf_output: out std_ulogic_vector(msb downto 0);
	   power:in std_logic);
end mspa_rs_buf_u_vec_vh;

architecture rtl of mspa_rs_buf_u_vec_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else (others => 'X');
end architecture;


library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_u_vh is
  port(buf_input: in std_ulogic;
	     buf_output: out std_ulogic;
	     power:in std_logic);
end mspa_rs_buf_u_vh;

architecture rtl of mspa_rs_buf_u_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else 'X';
end architecture;

----x01 types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_x01z_vh is
  port(buf_input: in x01z;
	     buf_output: out x01z;
	     power:in std_logic);
end mspa_rs_buf_x01z_vh;

architecture rtl of mspa_rs_buf_x01z_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else 'X';
end architecture;

----std_logic types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_vec_vh is
  generic(msb : integer := 0);
  port(buf_input: in std_logic_vector(msb downto 0);
	   buf_output: out std_logic_vector(msb downto 0);
	   power:in std_logic);
end mspa_rs_buf_vec_vh;

architecture rtl of mspa_rs_buf_vec_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else (others => 'X');
end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_vh is
  port(buf_input: in std_logic;
	     buf_output: out std_logic;
	     power:in std_logic);
end mspa_rs_buf_vh;

architecture rtl of mspa_rs_buf_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else 'X';
end architecture;

--ENUM TYPES MODEL---------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_enum_vh is
  port(buf_input: in Integer;
	     buf_output: out Integer;
       corrupt_value :in Integer;
	     power:in std_logic);
end mspa_rs_buf_enum_vh;

architecture rtl of mspa_rs_buf_enum_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else corrupt_value;
end architecture;

----BIT TYPE MODEL---------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_bit_vec_vh is
  generic(msb : integer := 0);
  port(buf_input: in bit_vector(msb downto 0);
	   buf_output: out bit_vector(msb downto 0);
	   power:in std_logic);
end mspa_rs_buf_bit_vec_vh;

architecture rtl of mspa_rs_buf_bit_vec_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else (others => '0');
end architecture;

library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_bit_vh is
  port(buf_input: in bit;
	     buf_output: out bit;
	     power:in std_logic);
end mspa_rs_buf_bit_vh;

architecture rtl of mspa_rs_buf_bit_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else '0';
end architecture;


----Integer types--------------------------------------
library ieee;
use ieee.std_logic_1164.all;
entity mspa_rs_buf_int_vh is
  generic(msb : integer := 0;
 	 	  lsb : integer := 0);
  port(buf_input: in integer range msb downto lsb;
			 buf_output: out integer range msb downto lsb;
			 corrupt_value :in integer;
			 power:in std_logic);
end mspa_rs_buf_int_vh;

architecture rtl of mspa_rs_buf_int_vh is
begin
			  pcs: buf_output <= buf_input when power = '1' else corrupt_value;
end architecture;

